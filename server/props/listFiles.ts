import { GetServerSideProps } from "next";
import { s3 } from "@/server/s3";
import mimetype from "mime-types";
import { redis } from "../../server/redis";
import { S3 } from "aws-sdk";

function compareValues(a: number | string, b: number | string) {
  if (typeof a === "number" && typeof b === "number") {
    return a - b;
  } else if (typeof a === "string" && typeof b === "string") {
    return a.localeCompare(b);
  } else {
    return typeof a === "number" ? -1 : 1;
  }
}

async function getAllObjects(): Promise<S3.Object[]> {
  let allObjects: AWS.S3.Object[] = [];

  // Initial call to listObjectsV2 with MaxKeys set to 1000
  let params: AWS.S3.ListObjectsV2Request = {
    Bucket: "malwarepadfiles",
    MaxKeys: 1000,
  };
  let result = await s3.listObjectsV2(params).promise();

  // Add the first batch of objects to the array
  allObjects = allObjects.concat(result.Contents || []);

  // Check if there are more objects to retrieve
  while (result.IsTruncated) {
    // Set the ContinuationToken to retrieve the next batch of objects
    params.ContinuationToken = result.NextContinuationToken;

    // Call listObjectsV2 again to retrieve the next batch of objects
    result = await s3.listObjectsV2(params).promise();

    // Add the next batch of objects to the array
    allObjects = allObjects.concat(result.Contents || []);
  }

  return allObjects;
}
export const getServerSideProps: GetServerSideProps = async (context) => {
  context.res.setHeader(
    "Cache-Control",
    "public, s-maxage=60, stale-while-revalidate=119"
  );

  const url = context?.params?.url
    ? new URL(
        "/" +
          (typeof context?.params?.url === "string"
            ? context?.params?.url
            : context?.params?.url?.join("/")),
        `http://${context?.req.headers["host}"]}`
      )
    : new URL("/", `http://${context?.req.headers["host}"]}`);
  if (!url) return { notFound: true };

  const possibleRedis = await redis.get("malwarepadfiles");

  var files;
  if (possibleRedis) {
    files = JSON.parse(possibleRedis);
    context.res.setHeader("redis", "HIT");
  } else {
    files = await getAllObjects();
    redis.set("malwarepadfiles", JSON.stringify(files));
    redis.expire("malwarepadfiles", 1800);
    context.res.setHeader("redis", "MISS");
  }

  if ((files?.length || 0) < 1) return { notFound: true };

  const resolvedPathname = url.pathname.replaceAll("%20", " ");

  if (
    files?.some(
      (o: fileType[0]) =>
        "/" + o.Key === resolvedPathname.replaceAll("%20", " ")
    )
  )
    return {
      redirect: {
        destination: `${[process.env.NEXT_PUBLIC_CDN]}${resolvedPathname}`,
        permanent: true,
      },
    };

  const relevantFiles = JSON.parse(JSON.stringify(files))
    ?.filter(
      (o: fileType[0]) =>
        o.Key.startsWith(resolvedPathname.substring(1) || "") &&
        !o.Key.replace(
          resolvedPathname.substring(1)
            ? resolvedPathname.substring(1) + "/"
            : "",
          ""
        ).includes("/")
    )
    ?.map((o: fileType[0]) => ({
      ...o,
      Key: o.Key.replaceAll(/.*\//g, ""),
      mime: mimetype.lookup(o?.Key?.split(".")?.pop() || "") || "other",
    }))
    ?.filter((o: fileType[0]) => o.Key)
    ?.sort((a: fileType[0], b: fileType[0]) => compareValues(a.Key, b.Key));

  const relevantFolderPossibilities: fileType = JSON.parse(
    JSON.stringify(files)
  )
    ?.filter(
      (o: fileType[0]) =>
        o.Key.startsWith(resolvedPathname.substring(1)) &&
        (resolvedPathname === "/" ||
          o.Key.replace(resolvedPathname.substring(1) + "/", "").includes("/"))
    )
    ?.map((o: fileType[0]) => ({
      ...o,
      mime: mimetype.lookup(o?.Key?.split(".")?.pop() || "") || "other",
    }));

  var relevantFolders: folderType = [];

  for await (const folder of relevantFolderPossibilities) {
    const path = resolvedPathname.substring(1);
    const Key = folder.Key.replace(path ? path + "/" : "", "").replaceAll(
      /\/.*/g,
      ""
    );
    const index = relevantFolders.findIndex((o) => o.Key === Key);
    if (index === -1) {
      relevantFolders.push({
        Items: 1,
        Size: folder.Size,
        LastModified: folder.LastModified,
        Key,
      });
    } else {
      relevantFolders[index] = {
        ...relevantFolders[index],
        LastModified:
          new Date(relevantFolders[index].LastModified) >
          new Date(folder.LastModified)
            ? relevantFolders[index].LastModified
            : folder.LastModified,
        Items: relevantFolders[index].Items + 1,
        Size: relevantFolders[index].Size + folder.Size,
      };
    }
  }

  if ((relevantFiles?.length || 0) < 1 && (relevantFolders?.length || 0) < 1)
    return { notFound: true };

  return {
    props: {
      files: relevantFiles,
      folders: relevantFolders,
      path: url.pathname,
    },
  };
};
